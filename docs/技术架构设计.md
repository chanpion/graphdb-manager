# 图数据库管理系统 - 技术架构设计

## 1. 技术架构概述

本系统采用**前后端分离架构**，后端采用**Spring Boot多模块Maven项目**，前端采用**Vue 3单页应用**。整体架构遵循**分层设计原则**和**插件化设计理念**，实现高内聚低耦合的系统架构。

## 2. 整体技术架构

### 2.1 架构图

```
┌──────────────────────────────────────────────────────────────────────────┐
│                      前端层 (Frontend Layer)                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  Vue 3 + Element Plus Application                      │   │
│  │  ├── Components: UI组件层                              │   │
│  │  ├── Views: 页面视图层                                │   │
│  │  ├── Store: Pinia状态管理                              │   │
│  │  ├── API: HTTP请求封装                                 │   │
│  │  └── Graph: D3.js可视化组件                         │   │
│  └─────────────────────────────────────────────────────┘   │
│                       ↓ HTTP/HTTPS                           │
└──────────────────────────────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────────────────────────────┐
│                    API网关层 (API Gateway Layer)               │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  graph-manager-api (Spring Boot Module)                  │   │
│  │  ├── Controllers: RESTful API端点                    │   │
│  │  ├── DTOs: 数据传输对象                                │   │
│  │  ├── GlobalExceptionHandler: 全局异常处理              │   │
│  │  └── SecurityConfig: 安全配置                          │   │
│  └─────────────────────────────────────────────────────┘   │
│                       ↓ Internal Call                        │
└──────────────────────────────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────────────────────────────┐
│                    业务服务层 (Service Layer)                      │
│  ┌────────────────────────────┐  ┌────────────────────────────┐   │
│  │ ConnectionService       │  │ GraphOperationService     │   │
│  └────────────────────────────┘  └────────────────────────────┘   │
│  ┌────────────────────────────┐  ┌────────────────────────────┐   │
│  │ DataOperationService     │  │ SchemaService             │   │
│  └────────────────────────────┘  └────────────────────────────┘   │
│  ┌────────────────────────────┐  ┌────────────────────────────┐   │
│  │ ImportExportService      │  │ NativeQueryService         │   │
│  └────────────────────────────┘  └────────────────────────────┘   │
└──────────────────────────────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────────────────────────────┐
│                    领域层 (Domain Layer)                        │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  graph-manager-core (Spring Boot Module)                  │   │
│  │  ├── Domain Models: 业务领域模型                     │   │
│  │  └── Interfaces: 业务接口定义                          │   │
│  └─────────────────────────────────────────────────────┘   │
└──────────────────────────────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────────────────────────────┐
│                    适配器层 (Adapter Layer)                     │
│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────┐   │
│  │ adapter-neo4j    │  │ adapter-nebula   │  │ adapter-janus │   │
│  │  ├── Neo4jAdapter │  │ NebulaAdapter    │  │ JanusAdapter │   │
│  │  ├── SchemaHandler │  │ SchemaHandler   │  │ SchemaHandler│   │
│  │  ├── DataHandler   │  │ DataHandler     │  │ DataHandler  │   │
│  │  └── QueryHandler  │  │ QueryHandler    │  │ QueryHandler│   │
│  └──────────────────┘  └──────────────────┘  └──────────────┘   │
└──────────────────────────────────────────────────────────────────────────┘
      ↓            ↓                ↓
┌──────────────────────────────────────────────────────────────────────────┐
│                    持久层 (Persistence Layer)                    │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │  graph-manager-storage (Spring Boot Module)               │   │
│  │  ├── MySQL Repositories: JPA数据访问                    │   │
│  │  └── Entity Classes: JPA实体类                      │   │
│  └─────────────────────────────────────────────────────┘   │
└──────────────────────────────────────────────────────────────────────────┘
                      ↓
┌──────────────────────────────────────────────────────────────────────────┐
│              图数据库存储层 (Graph Database Layer)              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐     │
│  │ Neo4j        │  │ NebulaGraph   │  │ JanusGraph    │     │
│  │ (Bolt Driver) │  │ (Java Client) │  │ (Core)        │     │
│  └──────────────┘  └──────────────┘  └──────────────┘     │
│                      ↓ HBase/Cassandra (Janus)                        │
└──────────────────────────────────────────────────────────────────────────┘
```

### 2.2 技术选型

#### 2.2.1 前端技术栈

| 技术分类 | 技术选型 | 版本 | 选型理由 |
|---------|---------|------|---------|
| 前端框架 | Vue 3 | 3.4+ | Composition API性能优异，生态成熟，TypeScript支持 |
| 构建工具 | Vite | 5.0+ | 开发服务器快速，HMR热更新 |
| UI组件库 | Element Plus | 2.4+ | 企业级组件，设计规范，文档完善 |
| 数据可视化 | D3.js | 7.8+ | 强大的数据驱动文档操作，图可视化最佳选择 |
| 状态管理 | Pinia | 2.1+ | Vue官方推荐，轻量级，TypeScript友好 |
| HTTP客户端 | Axios | 1.6+ | 拦截器支持，取消请求，并发控制 |
| 图表库 | ECharts | 5.4+ | 统计图表展示 |
| 样式方案 | Tailwind CSS | 3.4+ | 原子化CSS，开发效率高 |

#### 2.2.2 后端技术栈

| 技术分类 | 技术选型 | 版本 | 选型理由 |
|---------|---------|------|---------|
| 核心框架 | Spring Boot | 3.2+ | 企业级框架，生态完善，自动配置 |
| Java版本 | Java | 17+ | LTS版本，性能优异 |
| 构建工具 | Maven | 3.8+ | 多模块管理，依赖管理规范 |
| ORM框架 | Spring Data JPA | 3.2+ | 简化数据访问，约定优于配置 |
| 数据库 | MySQL | 8.0+ | 关系型数据库，元数据存储 |
| 缓存 | Redis | 7.0+ | 高性能缓存，支持集群 |
| 图数据库驱动 | - | - | 见下文详细说明 |
| API文档 | Springdoc/OpenAPI | 3.0+ | 自动生成API文档 |
| 安全框架 | Spring Security + JWT | 6.3+ | 成熟的安全框架 |
| 日志框架 | SLF4J + Logback | 2.0+ | 统一日志管理 |

#### 2.2.3 图数据库驱动

| 图数据库类型 | 驱动/客户端 | 版本 | 特性说明 |
|----------|----------|------|---------|
| Neo4j | Neo4j Java Driver | 5.12+ | Bolt协议，高性能连接 |
| NebulaGraph | Nebula Java Client | 3.0+ | 原生支持多图 |
| JanusGraph | JanusGraph Core | 0.6.0+ | HBase/Cassandra存储支持 |

## 3. 模块划分

### 3.1 后端模块结构

```
graph-manager/ (父项目)
│
├── graph-manager-api/                    # API网关模块
│   ├── src/main/java/com/graphmanager/api/
│   │   ├── controller/
│   │   │   ├── ConnectionController.java
│   │   │   ├── GraphOperationController.java
│   │   │   ├── DataOperationController.java
│   │   │   ├── SchemaController.java
│   │   │   ├── ImportExportController.java
│   │   │   └── NativeQueryController.java
│   │   ├── dto/
│   │   │   ├── request/           # 请求DTO
│   │   │   └── response/          # 响应DTO
│   │   ├── config/
│   │   │   ├── SecurityConfig.java
│   │   │   └── WebMvcConfig.java
│   │   └── exception/
│   │       ├── GlobalExceptionHandler.java
│   │       └── BusinessException.java
│   └── pom.xml
│
├── graph-manager-core/                    # 核心模块
│   ├── src/main/java/com/graphmanager/core/
│   │   ├── model/
│   │   │   ├── Connection.java
│   │   │   ├── GraphInstance.java
│   │   │   ├── NodeType.java
│   │   │   ├── EdgeType.java
│   │   │   ├── Property.java
│   │   │   ├── Index.java
│   │   │   ├── Vertex.java
│   │   │   └── Edge.java
│   │   ├── enums/
│   │   │   ├── DatabaseType.java
│   │   │   ├── GraphStatus.java
│   │   │   └── PropertyType.java
│   │   └── interfaces/
│   │       ├── GraphAdapter.java          # 图数据库适配器接口
│   │       ├── SchemaHandler.java         # Schema处理接口
│   │       ├── DataHandler.java           # 数据处理接口
│   │       └── GraphPlugin.java          # 插件标识接口
│   └── pom.xml
│
├── graph-manager-service/                 # 业务服务模块
│   ├── src/main/java/com/graphmanager/service/
│   │   ├── connection/
│   │   │   ├── ConnectionService.java
│   │   │   └── impl/
│   │   │       └── ConnectionServiceImpl.java
│   │   ├── graph/
│   │   │   ├── GraphOperationService.java
│   │   │   └── impl/
│   │   │       └── GraphOperationServiceImpl.java
│   │   ├── data/
│   │   │   ├── DataOperationService.java
│   │   │   └── impl/
│   │   │       └── DataOperationServiceImpl.java
│   │   ├── schema/
│   │   │   ├── SchemaService.java
│   │   │   └── impl/
│   │   │       └── SchemaServiceImpl.java
│   │   └── importexport/
│   │       ├── ImportExportService.java
│   │       └── impl/
│   │           └── ImportExportServiceImpl.java
│   └── pom.xml
│
├── graph-manager-adapter-neo4j/          # Neo4j适配器模块
│   ├── src/main/java/com/graphmanager/adapter/neo4j/
│   │   ├── Neo4jAdapter.java
│   │   ├── Neo4jSchemaHandler.java
│   │   ├── Neo4jDataHandler.java
│   │   ├── Neo4jQueryHandler.java
│   │   ├── config/
│   │   │   └── Neo4jConfig.java
│   │   └── model/
│   │       └── converter/
│   │           ├── Neo4jModelConverter.java
│   │           └── PropertyConverter.java
│   └── pom.xml
│
├── graph-manager-adapter-nebula/         # NebulaGraph适配器模块
│   ├── src/main/java/com/graphmanager/adapter/nebula/
│   │   ├── NebulaAdapter.java
│   │   ├── NebulaSchemaHandler.java
│   │   ├── NebulaDataHandler.java
│   │   ├── NebulaQueryHandler.java
│   │   ├── config/
│   │   │   └── NebulaConfig.java
│   │   └── model/
│   │       └── converter/
│   │           ├── NebulaModelConverter.java
│   │           └── PropertyConverter.java
│   └── pom.xml
│
├── graph-manager-adapter-janus/          # JanusGraph适配器模块
│   ├── src/main/java/com/graphmanager/adapter/janus/
│   │   ├── JanusAdapter.java
│   │   ├── JanusSchemaHandler.java
│   │   ├── JanusDataHandler.java
│   │   ├── JanusQueryHandler.java
│   │   ├── config/
│   │   │   └── JanusConfig.java
│   │   │   └── storage/
│   │   │       ├── HBaseStorage.java
│   │   │       └── CassandraStorage.java
│   │   └── model/
│   │       └── converter/
│   │           ├── JanusModelConverter.java
│   │           └── PropertyConverter.java
│   └── pom.xml
│
└── graph-manager-storage/                # 持久层模块
    ├── src/main/java/com/graphmanager/storage/
    │   ├── entity/
    │   │   ├── ConnectionEntity.java
    │   │   ├── GraphInstanceEntity.java
    │   │   ├── SchemaCacheEntity.java
    │   │   ├── OperationLogEntity.java
    │   │   ├── QueryHistoryEntity.java
    │   │   └── QueryScriptEntity.java
    │   ├── repository/
    │   │   ├── ConnectionMapper.java
    │   │   ├── GraphInstanceMapper.java
    │   │   ├── OperationLogMapper.java
    │   │   ├── QueryHistoryMapper.java
    │   │   └── QueryScriptMapper.java
    │   └── config/
    │       ├── MyBatisPlusConfig.java
    │       └── RedisConfig.java
    └── pom.xml
```

### 3.2 模块依赖关系

```
graph-manager-api
    ↓ 依赖
graph-manager-core
graph-manager-service
    ↓ 依赖
graph-manager-core
graph-manager-adapter-neo4j
    ↓ 依赖
graph-manager-core
graph-manager-adapter-nebula
    ↓ 依赖
graph-manager-core
graph-manager-adapter-janus
    ↓ 依赖
graph-manager-core
graph-manager-storage
    ↓ 依赖
graph-manager-core
```

## 4. 核心接口设计

### 4.1 图数据库适配器接口

#### 4.1.1 GraphAdapter接口

```java
package com.graphmanager.core.interfaces;

import com.graphmanager.core.model.*;
import java.util.List;
import java.util.Map;

/**
 * 图数据库适配器统一接口
 * 所有图数据库实现必须实现此接口
 */
public interface GraphAdapter {
    
    /**
     * 获取适配器类型
     * @return 数据库类型标识
     */
    String getDatabaseType();
    
    /**
     * 测试连接
     * @param config 连接配置
     * @return 是否连接成功
     * @throws ConnectionException 连接异常
     */
    boolean testConnection(ConnectionConfig config) throws ConnectionException;
    
    /**
     * 建立连接
     * @param config 连接配置
     * @throws ConnectionException 连接异常
     */
    void connect(ConnectionConfig config) throws ConnectionException;
    
    /**
     * 断开连接
     */
    void disconnect();
    
    /**
     * 判断是否已连接
     * @return 连接状态
     */
    boolean isConnected();
    
    // ==================== 图操作 ====================
    
    /**
     * 获取所有图实例
     * @return 图实例列表
     * @throws GraphOperationException 操作异常
     */
    List<GraphInstance> listGraphs() throws GraphOperationException;
    
    /**
     * 创建图实例
     * @param graphName 图名称
     * @throws GraphOperationException 操作异常
     */
    void createGraph(String graphName) throws GraphOperationException;
    
    /**
     * 删除图实例
     * @param graphName 图名称
     * @throws GraphOperationException 操作异常
     */
    void deleteGraph(String graphName) throws GraphOperationException;
    
    // ==================== Schema操作 ====================
    
    /**
     * 获取图Schema
     * @param graphName 图名称
     * @return Schema信息
     * @throws SchemaException Schema异常
     */
    GraphSchema getGraphSchema(String graphName) throws SchemaException;
    
    /**
     * 创建节点类型
     * @param graphName 图名称
     * @param nodeType 节点类型定义
     * @throws SchemaException Schema异常
     */
    void createNodeType(String graphName, NodeType nodeType) throws SchemaException;
    
    /**
     * 创建边类型
     * @param graphName 图名称
     * @param edgeType 边类型定义
     * @throws SchemaException Schema异常
     */
    void createEdgeType(String graphName, EdgeType edgeType) throws SchemaException;
    
    /**
     * 创建索引
     * @param graphName 图名称
     * @param index 索引定义
     * @throws SchemaException Schema异常
     */
    void createIndex(String graphName, Index index) throws SchemaException;
    
    // ==================== 数据操作 ====================
    
    /**
     * 查询节点
     * @param graphName 图名称
     * @param queryCondition 查询条件
     * @return 节点列表
     * @throws DataOperationException 数据操作异常
     */
    List<Vertex> queryVertices(String graphName, QueryCondition queryCondition) 
        throws DataOperationException;
    
    /**
     * 查询边
     * @param graphName 图名称
     * @param queryCondition 查询条件
     * @return 边列表
     * @throws DataOperationException 数据操作异常
     */
    List<Edge> queryEdges(String graphName, QueryCondition queryCondition) 
        throws DataOperationException;
    
    /**
     * 创建节点
     * @param graphName 图名称
     * @param vertex 节点数据
     * @return 创建的节点
     * @throws DataOperationException 数据操作异常
     */
    Vertex createVertex(String graphName, Vertex vertex) 
        throws DataOperationException;
    
    /**
     * 创建边
     * @param graphName 图名称
     * @param edge 边数据
     * @return 创建的边
     * @throws DataOperationException 数据操作异常
     */
    Edge createEdge(String graphName, Edge edge) 
        throws DataOperationException;
    
    /**
     * 更新节点
     * @param graphName 图名称
     * @param uid 节点UID
     * @param properties 更新的属性
     * @throws DataOperationException 数据操作异常
     */
    void updateVertex(String graphName, String uid, Map<String, Object> properties) 
        throws DataOperationException;
    
    /**
     * 更新边
     * @param graphName 图名称
     * @param uid 边UID
     * @param properties 更新的属性
     * @throws DataOperationException 数据操作异常
     */
    void updateEdge(String graphName, String uid, Map<String, Object> properties) 
        throws DataOperationException;
    
    /**
     * 删除节点
     * @param graphName 图名称
     * @param uid 节点UID
     * @param cascadeDelete 是否级联删除关联边
     * @throws DataOperationException 数据操作异常
     */
    void deleteVertex(String graphName, String uid, boolean cascadeDelete) 
        throws DataOperationException;
    
    /**
     * 删除边
     * @param graphName 图名称
     * @param uid 边UID
     * @throws DataOperationException 数据操作异常
     */
    void deleteEdge(String graphName, String uid) 
        throws DataOperationException;
    
    /**
     * 批量导入节点
     * @param graphName 图名称
     * @param vertices 节点列表
     * @param batchSize 批量大小
     * @return 导入结果
     * @throws ImportException 导入异常
     */
    ImportResult batchImportVertices(String graphName, List<Vertex> vertices, int batchSize) 
        throws ImportException;
    
    /**
     * 批量导入边
     * @param graphName 图名称
     * @param edges 边列表
     * @param batchSize 批量大小
     * @return 导入结果
     * @throws ImportException 导入异常
     */
    ImportResult batchImportEdges(String graphName, List<Edge> edges, int batchSize) 
        throws ImportException;
}
```

### 4.2 Schema处理接口

```java
package com.graphmanager.core.interfaces;

/**
 * Schema处理接口
 */
public interface SchemaHandler {
    
    /**
     * 获取节点类型列表
     * @param graphName 图名称
     * @return 节点类型列表
     */
    List<NodeType> getNodeTypes(String graphName);
    
    /**
     * 获取边类型列表
     * @param graphName 图名称
     * @return 边类型列表
     */
    List<EdgeType> getEdgeTypes(String graphName);
    
    /**
     * 创建节点类型
     */
    void createNodeType(String graphName, NodeType nodeType);
    
    /**
     * 创建边类型
     */
    void createEdgeType(String graphName, EdgeType edgeType);
}
```

### 4.3 数据处理接口

```java
package com.graphmanager.core.interfaces;

/**
 * 数据处理接口
 */
public interface DataHandler {
    
    /**
     * 查询节点
     */
    List<Vertex> queryVertices(String graphName, QueryCondition condition);
    
    /**
     * 查询边
     */
    List<Edge> queryEdges(String graphName, QueryCondition condition);
    
    /**
     * 创建节点
     */
    Vertex createVertex(String graphName, Vertex vertex);
    
    /**
     * 创建边
     */
    Edge createEdge(String graphName, Edge edge);
}
```

### 4.4 原生查询处理接口

```java
package com.graphmanager.core.interfaces;

import java.util.List;
import java.util.Map;

/**
 * 原生查询处理接口
 * 支持Cypher、nGQL、Gremlin等查询语言
 */
public interface QueryHandler {
    
    /**
     * 执行原生查询
     * @param graphName 图名称
     * @param query 查询语句
     * @param timeout 超时时间（秒）
     * @param limit 结果集限制
     * @return 查询结果
     * @throws QueryException 查询异常
     */
    QueryResult executeQuery(String graphName, String query, int timeout, int limit) 
        throws QueryException;
    
    /**
     * 获取查询执行计划
     * @param graphName 图名称
     * @param query 查询语句
     * @return 执行计划
     * @throws QueryException 查询异常
     */
    QueryPlan explainQuery(String graphName, String query) throws QueryException;
    
    /**
     * 验证查询语句语法
     * @param graphName 图名称
     * @param query 查询语句
     * @return 验证结果
     * @throws QueryException 查询异常
     */
    ValidationResult validateQuery(String graphName, String query) throws QueryException;
    
    /**
     * 获取支持的查询语言
     * @return 查询语言标识
     */
    String getQueryLanguage();
    
    /**
     * 获取查询模板
     * @param category 模板分类
     * @return 查询模板列表
     */
    List<QueryTemplate> getQueryTemplates(String category);
}
```

**查询结果模型**：
```java
package com.graphmanager.core.model;

import java.util.List;
import java.util.Map;

/**
 * 查询结果
 */
public class QueryResult {
    private long executionTimeMs;      // 执行时间（毫秒）
    private int resultCount;           // 结果数量
    private List<String> columns;      // 列名列表
    private List<Map<String, Object>> rows;  // 结果行数据
    private QueryPlan explain;         // 执行计划（可选）
    private Map<String, Object> metadata;  // 元数据
    
    // getters and setters
}
```

**查询计划模型**：
```java
package com.graphmanager.core.model;

import java.util.List;

/**
 * 查询执行计划
 */
public class QueryPlan {
    private String operator;           // 操作符
    private Map<String, Object> arguments;  // 参数
    private long estimatedRows;       // 预估行数
    private long dbHits;             // 数据库命中数
    private List<QueryPlan> children;  // 子计划
    private double totalCost;         // 总成本
    
    // getters and setters
}
```

**查询模板模型**：
```java
package com.graphmanager.core.model;

/**
 * 查询模板
 */
public class QueryTemplate {
    private String id;               // 模板ID
    private String name;             // 模板名称
    private String category;         // 模板分类
    private String description;      // 模板描述
    private String query;            // 查询语句
    private String databaseType;     // 数据库类型
    
    // getters and setters
}
```

**查询异常类**：
```java
package com.graphmanager.core.exception;

/**
 * 查询异常
 */
public class QueryException extends RuntimeException {
    private String errorCode;        // 错误码
    private String errorMessage;     // 错误信息
    private String suggestion;       // 建议解决方案
    
    public QueryException(String errorCode, String errorMessage) {
        super(errorMessage);
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
    }
    
    public QueryException(String errorCode, String errorMessage, String suggestion) {
        super(errorMessage);
        this.errorCode = errorCode;
        this.errorMessage = errorMessage;
        this.suggestion = suggestion;
    }
    
    // getters
}
```

## 5. 核心数据模型

### 5.1 连接配置模型

```java
package com.graphmanager.core.model;

public class ConnectionConfig {
    private String id;                    // 连接ID
    private String name;                  // 连接名称
    private DatabaseType databaseType;    // 数据库类型
    private String host;                  // 主机地址
    private Integer port;                 // 端口号
    private String username;              // 用户名
    private String password;              // 密码（加密）
    private String databaseName;           // 数据库名/图空间
    private String storageType;           // 存储类型（仅JanusGraph）
    private Map<String, Object> extraParams; // 额外参数（JSON）
    private ConnectionStatus status;        // 连接状态
    private Long createdAt;             // 创建时间
    private Long updatedAt;             // 更新时间
    
    // getters and setters
}
```

### 5.2 图数据模型

```java
package com.graphmanager.core.model;

/**
 * 节点数据模型
 * 包含唯一uid属性
 */
public class Vertex {
    private String uid;                   // 唯一标识符
    private String tagName;               // 节点类型
    private Map<String, Object> properties; // 属性集合
    private Long createdAt;              // 创建时间
    private Long updatedAt;              // 更新时间
    
    // getters and setters
}

/**
 * 边数据模型
 * 包含唯一uid属性
 */
public class Edge {
    private String uid;                   // 唯一标识符
    private String edgeType;              // 边类型
    private String sourceUid;            // 起始节点uid
    private String targetUid;            // 目标节点uid
    private Map<String, Object> properties; // 属性集合
    private Long createdAt;              // 创建时间
    private Long updatedAt;              // 更新时间
    
    // getters and setters
}

/**
 * 图实例信息
 */
public class GraphInstance {
    private String graphName;             // 图名称
    private DatabaseType databaseType;    // 数据库类型
    private Long vertexCount;           // 节点数量
    private Long edgeCount;             // 边数量
    private GraphStatus status;           // 图状态
    private Long createdAt;             // 创建时间
    
    // getters and setters
}
```

### 5.3 Schema数据模型

```java
package com.graphmanager.core.model;

/**
 * 节点类型定义
 */
public class NodeType {
    private String name;                    // 类型名称
    private List<PropertyDefinition> properties; // 属性定义
    private Long createdAt;              // 创建时间
    
    // getters and setters
}

/**
 * 边类型定义
 */
public class EdgeType {
    private String name;                    // 类型名称
    private String fromNodeType;          // 起始节点类型约束
    private String toNodeType;            // 目标节点类型约束
    private List<PropertyDefinition> properties; // 属性定义
    private Long createdAt;              // 创建时间
    
    // getters and setters
}

/**
 * 属性定义
 */
public class PropertyDefinition {
    private String name;                    // 属性名称
    private PropertyType type;            // 数据类型
    private boolean required;              // 是否必填
    private Object defaultValue;          // 默认值
    private String description;           // 描述
    
    // getters and setters
}
```

## 6. 数据流转设计

### 6.1 请求处理流程

```
前端请求 → Spring MVC DispatcherServlet
    ↓
拦截器链 (Security Interceptor)
    ↓JWT认证、CORS处理、日志记录
    ↓
Controller → 接收请求参数
    ↓
参数校验 (Validation)
    ↓DTO转换
    ↓
Service层调用 → 业务逻辑处理
    ↓
Repository/Adapter访问 → 数据操作
    ↓
返回结果 → Controller组装响应
    ↓
全局异常处理 (GlobalExceptionHandler)
    ↓
返回JSON响应 → 前端接收
```

### 6.2 图发现流程

```
用户连接图数据库
    ↓
PluginManager → 加载对应适配器
    ↓
Adapter → 调用图数据库元数据API
  - Neo4j: SHOW DATABASES
  - NebulaGraph: SHOW SPACES
  - JanusGraph: graph.listGraphs()
    ↓
适配器转换数据 → 统一为GraphInstance列表
    ↓
SchemaService → 缓存到MySQL
    ↓
返回给前端 → 显示图列表
```

### 6.3 Schema同步流程

```
用户切换图实例
    ↓
GraphOperationService → 触发Schema同步
    ↓
Adapter → 查询图数据库Schema
  - Neo4j: CALL db.labels() / CALL db.schema.relationshipTypes()
  - NebulaGraph: DESCRIBE TAG / DESCRIBE EDGE
  - JanusGraph: graph.getSchema()
    ↓
SchemaHandler → 转换为统一Schema格式
    ↓
SchemaService → 保存到MySQL缓存
    ↓
返回给前端 → 更新Schema视图
```

### 6.4 数据操作流程

```
用户执行CRUD操作
    ↓
DataOperationService → 校验Schema
    ↓
Adapter → 调用图数据库API
  - Neo4j: Cypher查询
  - NebulaGraph: nGQL查询
  - JanusGraph: Gremlin查询
    ↓
DataHandler → 转换为统一格式
    ↓
返回数据 → 前端渲染
```

## 7. 多图支持实现

### 7.1 Neo4j单图模式

```java
public class Neo4jAdapter implements GraphAdapter {
    
    @Override
    public List<GraphInstance> listGraphs() {
        // Neo4j社区版只有一个Database
        // 直接返回当前Database作为唯一图实例
        GraphInstance instance = new GraphInstance();
        instance.setGraphName(config.getDatabaseName());
        instance.setDatabaseType(DatabaseType.NEO4J);
        // 查询统计信息
        return Collections.singletonList(instance);
    }
    
    @Override
    public void createGraph(String graphName) {
        // 社区版不支持创建新Database
        throw new UnsupportedOperationException(
            "Neo4j Community Edition does not support creating new database. " +
            "Use Enterprise Edition or distinguish graphs by labels.");
    }
}
```

### 7.2 NebulaGraph多图模式

```java
public class NebulaAdapter implements GraphAdapter {
    
    @Override
    public List<GraphInstance> listGraphs() {
        // 查询所有Space
        ResultSet resultSet = session.execute("SHOW SPACES");
        List<GraphInstance> graphs = new ArrayList<>();
        while (resultSet.next()) {
            GraphInstance instance = new GraphInstance();
            instance.setGraphName(resultSet.getString("Name"));
            instance.setDatabaseType(DatabaseType.NEBULA);
            graphs.add(instance);
        }
        return graphs;
    }
    
    @Override
    public void createGraph(String graphName) {
        // 创建新Space
        String nGQL = String.format("CREATE SPACE IF NOT EXISTS %s", graphName);
        session.execute(nGQL);
    }
}
```

### 7.3 JanusGraph多图模式

```java
public class JanusAdapter implements GraphAdapter {
    
    private JanusGraphClient graph;
    private JanusGraphManagement management;
    
    @Override
    public List<GraphInstance> listGraphs() {
        // 列出所有Graph实例
        Iterable<Graph> graphs = management.getGraphs();
        List<GraphInstance> instances = new ArrayList<>();
        for (Graph graph : graphs) {
            GraphInstance instance = new GraphInstance();
            instance.setGraphName(graph.name());
            instance.setDatabaseType(DatabaseType.JANUS);
            instances.add(instance);
        }
        return instances;
    }
    
    @Override
    public void createGraph(String graphName) {
        // 创建新Graph实例
        Graph newGraph = management.openGraph(graphName);
        // 配置存储后端（HBase或Cassandra）
        if (config.getStorageType().equals("HBASE")) {
            configureHBaseStorage(newGraph);
        } else if (config.getStorageType().equals("CASSANDRA")) {
            configureCassandraStorage(newGraph);
        }
    }
}
```

## 8. JanusGraph存储支持

### 8.1 HBase存储配置

```java
public class HBaseStorage implements StorageBackend {
    
    private Connection hbaseConnection;
    
    public void configure(String graphName, ConnectionConfig config) {
        // 配置HBase连接
        Configuration conf = HBaseConfiguration.create();
        conf.set("hbase.zookeeper.quorum", config.getExtraParams().get("zookeeper.quorum"));
        hbaseConnection = ConnectionFactory.createConnection(conf);
        
        // 创建表
        createTablesIfNotExists();
    }
    
    private void createTablesIfNotExists() {
        Admin admin = hbaseConnection.getAdmin();
        // 节点表
        TableDescriptor vertexTable = TableDescriptorBuilder
            .newBuilder(TableName.valueOf(graphName + "_vertices"))
            .setColumnFamily(ColumnFamilyDescriptorBuilder.newBuilder("cf").build())
            .build();
        // 边表
        TableDescriptor edgeTable = TableDescriptorBuilder
            .newBuilder(TableName.valueOf(graphName + "_edges"))
            .setColumnFamily(ColumnFamilyDescriptorBuilder.newBuilder("cf").build())
            .build();
        
        admin.createTable(vertexTable);
        admin.createTable(edgeTable);
    }
}
```

### 8.2 Cassandra存储配置

```java
public class CassandraStorage implements StorageBackend {
    
    private Session cassandraSession;
    
    public void configure(String graphName, ConnectionConfig config) {
        // 配置Cassandra连接
        Cluster cluster = Cluster.builder()
            .addContactPoint(config.getHost(), config.getPort())
            .build();
        
        cassandraSession = cluster.connect();
        
        // 创建Keyspace和Table
        createSchemaIfNotExists(graphName);
    }
    
    private void createSchemaIfNotExists(String graphName) {
        // 节点表
        String createVertexTable = String.format(
            "CREATE TABLE IF NOT EXISTS %s.vertices (" +
            "uid text PRIMARY KEY, " +
            "tagName text, " +
            "properties map<text, text>);",
            graphName);
        
        // 边表
        String createEdgeTable = String.format(
            "CREATE TABLE IF NOT EXISTS %s.edges (" +
            "uid text PRIMARY KEY, " +
            "edgeType text, " +
            "sourceUid text, " +
            "targetUid text, " +
            "properties map<text, text>);",
            graphName);
        
        cassandraSession.execute(createVertexTable);
        cassandraSession.execute(createEdgeTable);
    }
}
```

## 9. 性能优化策略

### 9.1 前端性能优化

**虚拟滚动**：
- 使用vue-virtual-scroller库实现大列表虚拟滚动
- 只渲染可见区域的节点/边
- 减少DOM节点数量

**懒加载**：
- 图数据按需加载（初始加载500节点，滚动时加载更多）
- 使用Intersection Observer实现无限滚动
- 预加载相邻节点的边数据

**请求优化**：
- 使用axios请求取消
- 并发控制（最多3个并发请求）
- 请求防抖（300ms）

**D3.js优化**：
- 使用Canvas渲染替代SVG（节点数>1000时）
- 力导向模拟使用Web Worker后台计算
- 节点和边使用对象池复用

### 9.2 后端性能优化

**连接池管理**：
- Neo4j: 使用连接池，最大10个连接
- NebulaGraph: 使用Session池
- JanusGraph: 使用GraphConnection池

**缓存策略**：
- Schema缓存到MySQL，设置1小时过期
- 查询结果缓存到Redis，设置5分钟过期
- 图统计信息缓存，减少频繁查询

**批量操作**：
- CSV导入分批处理（每批100条）
- 批量删除使用事务
- 批量查询使用分页

**异步处理**：
- 使用@Async异步处理耗时操作
- 使用CompletableFuture并发调用多个适配器
- 使用Spring Event事件驱动架构

### 9.3 数据库优化

**MySQL优化**：
- 连接配置表添加索引（name, database_type）
- Schema缓存表添加索引（graph_name, cache_time）
- 操作日志表按时间分区存储

**图数据库优化**：
- Neo4j: 创建索引加速查询
- NebulaGraph: 配置合理的分区和副本数
- JanusGraph: 优化HBase/Cassandra的Region和Replication

## 10. 安全架构设计

### 10.1 认证授权

**JWT认证**：
```java
@Configuration
@EnableWebSecurity
public class SecurityConfig {
    
    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter() {
        return new JwtAuthenticationFilter();
    }
    
    @Bean
    public SecurityFilterChainFilter filterChain() {
        return new DefaultSecurityFilterChain(
            jwtAuthenticationFilter(),
            new CorsFilter(),
            new ExceptionTranslationFilter()
        );
    }
}
```

**RBAC权限控制**：
- 基于角色的访问控制（Admin, Developer, Analyst）
- 方法级权限注解@PreAuthorize
- 数据级权限校验（用户只能访问自己创建的图）

### 10.2 数据安全

**密码加密**：
```java
@Service
public class EncryptionService {
    
    private static final String SECRET_KEY = "graph-manager-secret-key";
    private static final String ALGORITHM = "AES/CBC/PKCS5Padding";
    
    public String encrypt(String password) {
        // AES-256加密
        Cipher cipher = Cipher.getInstance(ALGORITHM);
        SecretKeySpec keySpec = new SecretKeySpec(SECRET_KEY.getBytes(), "AES");
        cipher.init(Cipher.ENCRYPT_MODE, keySpec);
        return Base64.encode(cipher.doFinal(password.getBytes()));
    }
    
    public String decrypt(String encryptedPassword) {
        // AES-256解密
        // ...
    }
}
```

**防注入攻击**：
- 使用参数化查询（PreparedStatement）
- Cypher/nGQL/Gremlin查询参数化
- 输入验证和清理

### 10.3 API安全

**CORS配置**：
```java
@Configuration
public class WebMvcConfig implements WebMvcConfigurer {
    
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
            .allowedOrigins("*")
            .allowedMethods("GET", "POST", "PUT", "DELETE", "PATCH")
            .allowedHeaders("*")
            .allowCredentials(true);
    }
}
```

**限流**：
- 使用Redis实现接口限流
- 每IP每分钟最多100次请求
- 每用户每分钟最多200次请求

## 11. 监控和日志

### 11.1 日志架构

**日志级别**：
- ERROR: 系统错误，需要立即处理
- WARN: 警告信息，需要关注
- INFO: 关键操作，连接、查询、CRUD
- DEBUG: 调试信息，仅开发环境

**日志内容**：
- 操作日志：记录所有CRUD操作
- 访问日志：记录API访问（IP、User、Method、Path、Status、Time）
- 错误日志：记录异常堆栈信息

### 11.2 性能监控

**指标收集**：
- API响应时间（P50, P90, P99）
- 数据库查询时间
- 图数据库连接池使用率
- JVM内存和CPU使用率

**告警规则**：
- API响应时间 > 3s：发送告警
- 数据库连接失败 > 3次：发送告警
- 内存使用率 > 80%：发送告警

## 12. 扩展性设计

### 12.1 插件扩展机制

**SPI机制**：
```java
// 在adapter模块的META-INF/services目录下创建配置文件
// META-INF/services/com.graphmanager.core.interfaces.GraphAdapter
com.graphmanager.adapter.neo4j.Neo4jAdapter
com.graphmanager.adapter.nebula.NebulaAdapter
com.graphmanager.adapter.janus.JanusAdapter
```

**动态加载**：
```java
@Service
public class PluginManager {
    
    private final Map<String, GraphAdapter> adapters = new ConcurrentHashMap<>();
    
    @PostConstruct
    public void loadPlugins() {
        // 使用ServiceLoader动态加载所有实现
        ServiceLoader<GraphAdapter> loader = 
            ServiceLoader.load(GraphAdapter.class);
        
        for (GraphAdapter adapter : loader) {
            String type = adapter.getDatabaseType();
            adapters.put(type, adapter);
            log.info("Loaded adapter: {} for type: {}", 
                adapter.getClass().getSimpleName(), type);
        }
    }
    
    public GraphAdapter getAdapter(DatabaseType databaseType) {
        return adapters.get(databaseType.name());
    }
}
```

### 12.2 微服务化准备

**模块独立部署**：
- API模块可独立部署
- Service模块可独立部署
- Adapter模块可独立部署

**服务发现**：
- 使用Nacos或Eureka实现服务注册与发现
- 支持负载均衡

**配置中心**：
- 使用Nacos Config实现配置统一管理
- 支持配置动态刷新
